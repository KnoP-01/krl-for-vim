*krl.txt*	Kuka Robot Language for Vim version 7.4	Last change: 04. Apr 2019


		  VIM REFERENCE MANUAL    by Patrick Meiser-Knosowski
					  <knosowski@graeff.de>



Installation:
-------------

Extract the most recent release and copy the folders 
`/doc`, `/ftdetect`, `/ftplugin`, `/indent` and `/syntax` 
into your `~/.vim/` or `%USERPROFILE%\vimfiles\` directory. 
Overwrite krl.* files from older installation. 

To use these plugins put >
    filetype plugin indent on
    syntax on
in your .vimrc.

You may have to run >
    :helptags ~/.vim/doc/
or >
    :helptags ~/vimfiles/doc/
to use the help within Vim after installation. >
    :help krl


==============================================================================
                        *krl-Introducion*

KRL for Vim (7.4 or later) is a collection of Vim scripts to help programing
KUKA industrial robots. 

It provides
* syntax highlighting,
* auto indention,
* folding,
* mappings and settings to navigate through code in a backup folder structure,
* Text objects for functions and folds and
* mappings to insert a body of a new DEF, DEFFCT or DEFDAT based on user 
  defined templates or hopefully sane defaults.

Have a look at |krl-tl:dr| to get a quick overview over the most important
options provided by KRL for Vim.

Since version 2.0.0 most features are enabled by default, so you don't need
that many options in your .vimrc. Existing mappings don't get overridden,
unless the corrosponding option is explicitly set. There are <plug>-mappings
available too, if you prefere different key bindings.

KRL for Vim supports viewing and analysing VKRC files. Folding will get
optimized for VKRC and you can use your Go Definition mapping (default gd) on
a SPSMAKRO, UP, bin, binin or Marker in a fold line. However, this is NOT a
VKRC-Editor.

Note: Keep your files to be edited in one folder or in a regular robot
backup folder structure. KRL for Vim modifies 'path' accordingly. Since
version 2.0.0 KRC1 backups are supported too.
Note to linux users: Keep your files to be edited on a FAT file system. 
Some features need the case insensitive file system to work properly.


Index: |krl-index|
==============================================================================
                        *krl-tl:dr*
Short description:
------------------
Q: Since version 2.0.0 everything's weird. How so?
A: Most optional features are enabled by default now.

Q: I'm here to feed my kids, not to read. How do I get rid of stuff?  
A: Disable stuff in your |vimrc|, see |krl-options| for details: >

    let g:krlAutoComment = 0 " don't continue comments with o, O or Enter
    let g:krlFormatComments = 0 " don't break comment lines automatically
    let g:krlSpaceIndent = 0 " don't change 'sts', 'sw', 'et' and 'sr'
    let g:krlKeyWord = 0 " don't treat $, # and & as word char
    let g:krlShortenQFPath = 0 " don't shorten paths in quickfix

Q: Which keys get mapped to what?
A: If there is no existing mapping which would be overridden and no <plug>
    mapping is configured for that function then the following keys get
    mapped: >

    <F2> Switch folding off
    <F3> Close movement folds.
    <F4> Close all folds.
            Depend on g:krlFoldLevel not existing or >=1.
            Can be forced with
        let g:krlFoldingKeyMap = 1

    gd Go to or show definition of variable or def/deffct.
            Can be forced with
        let g:krlGoDefinitionKeyMap = 1

    <leader>u List all appearances of word under cursor outside a comment,
            string or enum declaration.
            Can be forced with
        let g:krlListUsageKeyMap = 1

    <leader>f List all def/deffct in the current file.
            Can be forced with
        let g:krlListDefKeyMap = 1

    [[ Move around functions. Takes a count.
    ]] Move around functions. Takes a count.
    [] Move around functions. Takes a count.
    ][ Move around functions. Takes a count.
    [; Move around comments. Takes a count.
    ]; Move around comments. Takes a count.
            Will override existing mappings!
            Can be forced off with
        let g:krlMoveAroundKeyMap = 0

    if Inner function text object.
    af Around function text object.
    aF Around function text object including preceding comments and one
        following empty line.
            Depend on g:krlMoveAroundKeyMap not existing or =1.
            Can be forced with
        let g:krlFunctionTextObject = 1

    io Inner fold text object. Takes a count for nested folds.
    ao Around fold text object. Takes a count for nested folds.
            Depend on matchit.
            Can be forced with 
        let g:krlFoldTextObject = 1

    <leader>n Inserts a new def/deffct.
            Can be forced with
        let g:krlAutoFormKeyMap = 1

Q: Does krl-for-vim provide a mapping for indenting a complete file?
A: No, but you may put the following in your .vimrc: >
    nnoremap ANYKEY gg=G``zz

Q: Scrolling feels sluggish. What can I do?
A: Switch error highlighting off and/or folding to marker: >

    let g:krlFoldMethodSyntax = 0 " better performance, but case sensitive
    let g:krlShowError = 0        " better performance

Q: Still sluggish!
A: Switch syntax off or jump instead of scroll!

Q: Where are the nice and informative messages?
A: `:let g:knopVerbose=1` any time.


Index: |krl-index|
                        *krl-content*
Content description:
--------------------
>
    ~/.vim/doc/krl.txt
    ~/.vim/ftdetect/krl.vim
    ~/.vim/ftplugin/krl.vim
    ~/.vim/indent/krl.vim
    ~/.vim/syntax/krl.vim

You may use all these independently from one another. Just don't mix versions
of different releases. Some features may work better when all files are loaded.

~/.vim/doc/krl.txt
Help file. This should help you to use these plugins to your best advantage.
Requires >
    :helptags ~/.vim/doc

~/.vim/ftdetect/krl.vim
Detects KRL files based on their file name ending and content. KRL files are 
checked for the presence of a DEF line or any &HEADER.
Requires >
    :filetype on

~/.vim/ftplugin/krl.vim
Sets various Vim options and provides key mappings and folding. It supports
commentary (vimscript #3695) and matchit (vimscript #39).
Requires >
    :filetype plugin on

~/.vim/indent/krl.vim
Sets indent related Vim options. Sets indention to 2 spaces by default,
optional.  
Requires >
    :filetype indent on

~/.vim/syntax/krl.vim
Does make life more colorful. Unfortunately some features of the other files
may work better with syntax on. This should not stop you from trying syntax
off if you like.  
Requires >
    :syntax on


==============================================================================
                        *krl*   *krl-index* 
==============================================================================

|krl-Introducion|
    |krl-tl:dr|     Short overview
    |krl-content|   What are those files for and how to activate them
|krl-options|       List of options and <plug> mappings
|krl-highlighting|
|krl-indent|
|krl-folding|
|krl-jump-quickly|
    |krl-matchit-support|
    |krl-text-objects|
|krl-formatting-comments|
|krl-auto-form|
|krl-known-bugs|
    |krl-indent-bugs|
    |krl-highlight-bugs|
    |krl-go-definition-bugs|


==============================================================================
                        *krl-options*
==============================================================================

Set or reset options in your .vimrc. Except |g:krlCommentIndent| and
|g:krlVerbose| changeing a krl option during editing will have no effect.

*krl-key-mappings*
Also see these options for alternative <PLUG> mappings.
|g:krlFoldingKeyMap|      `<F2>` - `<F4>` changes folding
|g:krlGoDefinitionKeyMap| `gd` to see declaration of word under cursor
|g:krlListUsageKeyMap|    `<leader>u` lists all appearances of current word
|g:krlListDefKeyMap|      `<leader>f` lists def/deffct of current file
|g:krlMoveAroundKeyMap|   `[[`, `]]` ... jumps around def/deffct
|g:krlFunctionTextObject| `if`, `af` and `aF` def/deffct text objects
|g:krlFoldTextObject|     `io` and `ao` fold text objects
|g:krlAutoFormKeyMap|     `<leader>n` inserts body for def, deffct or defdat

*krl-highlight-options*
|g:krlGroupName|          Enable/Disable krl specific |group-name|s
|g:krlShowError|          Disable error highlight, increase performance

*krl-indent-options*
|g:krlSpaceIndent|        Disable 'sts', 'sw', 'et' and 'sr' settings
|g:krlCommentIndent|      Disable indent of first column comments

*krl-folding-options*
|g:krlFoldLevel|          Change which folds get closed at start
|g:krlFoldMethodSyntax|   Fold method syntax or marker

*krl-comment-options*
|g:krlAutoComment|        Disable auto insert of comment char `;`
|g:krlFormatComments|     Disable auto break comment lines

*krl-auto-form-options*
|g:krlPathToBodyFiles|    Enable custom body files for auto form
|g:krlAutoFormUpperCase|  Enable conversion of auto form to upper case

*krl-jump-quickly-options*
|g:krlKeyWord|            Disable inclusion of `$`, `#` and `&` in 'iskeyword'
|g:krlShortenQFPath|      Disable shortening of paths in quickfix
|g:krlRhsQuickfix|        Open quickfix right hand side
|g:krlLhsQuickfix|        Open quickfix left hand side
|g:krlPath|               Disable 'path' setting
|g:krlVerbose|            Enable verbose messages


Index: |krl-index|
==============================================================================
                        *krl-highlighting*
==============================================================================
                        *g:krlShowError*
g:krlShowError:
---------------

Disable error highlighting:  >
    let g:krlShowError = 0

If omitted or set to 1 a few syntax errors get highlighted.
Mainly false usages of =, ==, <= and >= get highlighted. 
Note that this is not a syntax check.


Index: |krl-index|
                        *g:krlGroupName* 
g:krlGroupName:
---------------

With this option reset krl-for-vim does |hi-link| 
krlBuildInFunction to |group-name| `Function`, 
krlContinue to `Statement`,
krlMovement to `Special` and
krlSysvars to nothing: >
    let g:krlGroupName = 0

With this option set krl-for-vim does |hi-link| 
krlBuildInFunction to |group-name| `BuildInFunction`, 
krlContinue to `Continue`, 
krlMovement to `Movement` and 
krlSysvars to `Sysvars`: >
    let g:krlGroupName = 1

If omitted this option is automatically set if you use colorscheme
tortus or tortusless and reset for any other colorscheme. 

This is usefull if you want to set your own colors for Sysvars, Movement,
Continue and/or BuildInFunction:  >
    highlight Sysvars           guibg=Black     guifg=white
    highlight BuildInFunction   guibg=Black     guifg=#00d5d5
    highlight Continue          guibg=black     guifg=#646423
    highlight Movement          guibg=black     guifg=green

`krlBuildInFunction`    contains KSS functions.
`krlSysvars`            contains all variables starting with $.
`krlContinue`           contains the continue instruction.
`krlMovement`           contains movement instructions like ptp, lin and
                      movement modifiers like c_ptp and c_dis.

If you like it colorful and dark background you may try the 
colorscheme tortus or tortusless which makes use of these groups:
    https://github.com/KnoP-01/tortus


Index: |krl-index|
==============================================================================
                        *krl-indent*
==============================================================================
                        *g:krlSpaceIndent*
g:krlSpaceIndent:
-----------------

Disables the modification of 'softtabstop', 'expandtab', 'shiftwidth' 
and 'shiftround':  >
    let g:krlSpaceIndent = 0

If omitted or set to 1 the following Vim options get set:
    'softtabstop'   = 2
    'shiftwidth'    = 2
    'expandtab'
    'shiftround'

Keep in mind that space is rare and tabs look really awful on the teach
pendant.


Index: |krl-index|
                        *g:krlCommentIndent*
g:krlCommentIndent:
-------------------

Disable indent of line comments which start in the first column:  >
    let g:krlCommentIndent = 0

This is usefull if you commented out code like this: 
    wait for di_blubb
;    wait for di_bla or di_blubb
;    if di_bla then
;      do_bla()
;    endif
    do_blubb()

If omitted or set to 1 comments which start in the first column are indented
like everything else.

This option may be changed any time and will take effect immediately.


Index: |krl-index|
==============================================================================
                        *krl-folding*
==============================================================================
                        *g:krlFoldLevel*
g:krlFoldLevel:
---------------

Set this option to 2 makes closing all folds the starting behavior:  >
    let g:krlFoldLevel = 2

Set this option to 0 to switch folding off completely: >
   let g:krlFoldLevel = 0

If omitted or set to 1 only movement folds are closed. If set to 0
changeing folding via |g:krlFoldingKeyMap| is not possible.

See also |fold-commands| and |g:krlFoldMethodSyntax|.


Index: |krl-index|
                        *g:krlFoldMethodSyntax*
g:krlFoldMethodSyntax:
----------------------

Use 'foldmethod' |fold-marker| instead of |fold-syntax|.  >
   let g:krlFoldMethodSyntax = 0

If omitted or set to 1 'foldmethod' syntax is used. 'foldmethod' marker
uses less performance, but is case sensitive and will catch less movement
folds.


Index: |krl-index|
                        *g:krlFoldingKeyMap*       *<Plug>KrlCloseAllFolds*
                        *<Plug>KrlCloseLessFolds*  *<Plug>KrlCloseNoFolds*
g:krlFoldingKeyMap:
-------------------

Note: These mappings depend on |g:krlFoldLevel| >= 1 or omitted.

Regular KRC files and vw_usr*:
    `<F2>`: Switch folding off
    `<F3>`: Close only movement folds
    `<F4>`: Close all folds

VKRC FOLGE, UP and MAKRO:
    `<F2>`: Switch folding off
    `<F3>`: Close second level folds
    `<F4>`: Close all folds

To force those mappings if your F-Keys are already mapped: >
    let g:krlFoldingKeyMap = 1

Alternativ <plug> mappings: >
    augroup KrlFoldMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlCloseAllFolds
    au FileType krl nmap <silent><buffer> SOMEKEY <Plug>KrlCloseLessFolds
    au FileType krl nmap <silent><buffer> OTHERKEY <Plug>KrlCloseNoFolds
    augroup END


Index: |krl-index|
==============================================================================
                        *krl-jump-quickly*

Vim by itself provides a lot of nice features to get around quickly. Some of
those features depend on proper 'path' setting. Fortunatly krl-for-vim takes
care abput that and more for you.

Note to unix/linux users: Keep your files on a filesystem which ingores case
(e.g. FAT) or some of the following features may not work correctly.

ftplugin/krl.vim does set 'path', 'suffixes' and 'suffixesadd' to find files
within a regular KUKA backup folder structure. This is not only usefull for
commands like |:find|, |gf|, |^Wf| and the like but also necessary for some of
the following features.

You may instruct krl-for-vim not to change 'path' if you reset |g:krlPath|.
'suffixes' and 'suffixesadd' get their values unconditional. 

For the best experience keep your files below the `KRC/` or `R1/` folder.

Index: |krl-index|
==============================================================================
                        *g:krlGoDefinitionKeyMap*   *<Plug>KrlGoDef*
g:krlGoDefinitionKeyMap:
------------------------

Note: This mapping overshadows the default vim command |gd|.

    `gd`: Jump to or shows variable or def/deffct declarations.

To force this mapping off and make Vims default available: >
    let g:krlGoDefinitionKeyMap = 0

Alternativ <plug> mapping: >
    augroup KrlGoDefMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlGoDef
    augroup END

A succesful search for a file local declaration jumps there right away. Get
back where you were with |''|. A succesful search for a more global
declaration opens the |quickfix-window|. This also works for Markers, Bin,
BinIn, UPs and MAKROs in the fold lines: `;FOLD 4: SPSMAKRO23 = M15`

Works best with `:syntax on` and both |g:krlPath| and |g:krlKeyWord| omitted.

Limitations: See |krl-go-definition-bugs|.


Index: |krl-index|
                        *g:krlListUsageKeyMap*  *<Plug>KrlListUse*
g:krlListUsageKeyMap:
---------------------

    `<leader>u`: List all appearances, outside of strings, enum declarations
                and comments (unless used in a vkrc file), of the word under
                the cursor in the |quickfix-window|.

To force this mapping if `<leader>u` is already mapped: >
    let g:krlListUsageKeyMap = 1

Alternativ <plug> mapping: >
    augroup KrlListUseMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlListUse
    augroup END


Index: |krl-index|
                        *g:krlListDefKeyMap*    *<Plug>KrlListDef*
g:krlListDefKeyMap:
-------------------

    `<leader>f`: List def/deffct of the current file in the |quickfix-window|. >

To force this mapping if `<leader>f` is already mapped: >
    let g:krlListDefKeyMap = 1

Alternativ <plug> mapping: >
    augroup KrlListDefMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlListDef
    augroup END


Index: |krl-index|
                        *g:krlMoveAroundKeyMap*
g:krlMoveAroundKeyMap:
----------------------

Note: These mappings overshadow the default vim commands 
|[[|, |]]|, |[]| and |][|!

[count]`[[`   Jumps backward to the next def/deffct [count] times. Works in
            |Normal|-, |Visual|- and |Operator-pending|-mode, see |operator|. 
            In Normal-mode it respects 'wrapscan'.
       
[count]`]]`   Like [[ but jumps forward to the next def/deffct.
       
[count]`[]`   Like [[ but jumps backward to the next end/endfct.
       
[count]`][`   Like [[ but jumps forward to the next end/endfct.
       
[count]`[;`   Like [[ but jumps backward to the start of current or, if in
            between, previous comment.
       
[count]`];`   Like [[ but jumps forward to the end of the current or, if in
            between, next comment.

To force these mappings off and make Vims default available: >
    let g:krlMoveAroundKeyMap = 0

Note that |g:krlFunctionTextObject| depend on these mappings.


Index: |krl-index|
                        *g:krlKeyWord*
g:krlKeyWord:
-------------

Disables the inclusion of `#`, `&` and `$` into 'iskeyword':  >
    let g:krlKeyWord = 0

If omitted or set to 1 `$sysvars`, `#enumvalues` and `&header` are treated as
|word| for |word-motions|, |text-objects| and the like.


Index: |krl-index|
                        *g:krlShortenQFPath*
g:knopShortenQFPath:
--------------------

Note: g:krlShortenQFPath is synonym for g:knopShortenQFPath.
Use the g:knop* variable!

Disable shortening of paths that are longer than 40 char in quickfix-window: >
    let g:knopShortenQFPath = 0

If omitted or set to 1 full paths are shown in quickfix-window.

See also |pathshorten|.


Index: |krl-index|
                        *g:krlRhsQuickfix*   *g:krlLhsQuickfix*
g:knop[RL]hsQuickfix:
---------------------

Note: g:krl[RL]hsQuickfix is synonym for g:knop[RL]hsQuickfix.
Use the g:knop* variable!

Where to open the |quickfix-window| the first time.

Open quickfix-window right hand side: >
    let g:knopRhsQuickfix = 1

Open quickfix-window left hand side: >
    let g:knopLhsQuickfix = 1

If you use |vim-qf|.vim (vimscript #5211) these options will not work
unless g:|qf_window_bottom| is 0: >
    let g:qf_window_bottom = 0


Index: |krl-index|
                        *g:krlPath*
g:krlPath:
----------

Disables the modification of 'path': >
    let g:krlPath = 0

If omitted or set to 1 krl-for-vim tries to set 'path' to the root
`.../KRC/**` of a kuka backup.

Note: Many features of krl-for-vim depend on a proper 'path' setting.

Expected folder structure:

`KRC1`:         `KRC2+`:                                `VKRC2+`:
MaDa/         KRC/                                  KRC/
  +-R1/         +-R1/                                 +-R1/
  +-Steu/       |  +-Mada/                            |  +-Folgen/
PowerOn/        |  +-Program/                         |  +-Mada/
  +-R1/         |  |    `+-UpToTwo/SubFolders/`         |  +-Makros/
  +-Steu/       |  +-System/                          |  +-System/
                |  +-TP/                              |  +-UPs/
                +-STEU/                               |  +-VW_User/
                    +-Mada/                           +-STEU/
                                                          +-Mada/

krl-for-vim looks up to 5 levels upward for a `KRC/` folder. If found
`/absolut/path/KRC/**` gets added to 'path'. See |starstar|.
If not found krl-for-vim looks up to 4 levels upward for `R1/` and 2 levels up for
`STEU/` folders. If found `/absolut/path/R1/**` and `/absolut/path/Steu/**`
gets added.
If not found krl-for-vim tries to find `Mada`, `Program`, `System` and `TP`. But
it's best to work below a `KRC` folder or at least below a `R1` folder. 


Index: |krl-index|
                        *g:krlVerbose*
g:knopVerbose:
--------------

Note: g:krlVerbose is synonym for g:knopVerbose.
Use the g:knop* variable!

Enable verbose messages: >
    let g:knopVerbose = 1

If omitted or set to 0 no messages are generate by krl-for-vim.

This option may be changed any time and will take effect immediately.


Index: |krl-index|
                        *krl-matchit-support*  
Match it support:
-----------------
You may have to install the matchit plugin to use this. See |matchit-install|
for help on this. See also http://www.vim.org/scripts/script.php?script_id=39

If |matchit| is loaded you can use |%| to not only jump between (), [] and {}
but also between >
    DEF -> RESUME -> RETURN -> END,
    DEFFCT -> RESUME -> RETURN -> ENDFCT,
    DEFDAT -> ENDDAT,
    IF -> ELSE -> ENDIF, 
    FOR -> EXIT -> ENDFOR, 
    REPEAT -> EXIT -> UNTIL, 
    WHILE -> EXIT -> ENDWHILE,
    LOOP -> EXIT -> ENDLOOP,
    SWITCH -> CASE -> DEFAULT -> ENDSWITCH and
    FOLD -> ENDFOLD


Index: |krl-index|
==============================================================================
                        *krl-text-objects*  

Krl text objects work similar as |text-objects|.
They can be used in |Visual|- and |Operator-pending|-mode, see |operator|. 

==============================================================================
                    *g:krlFunctionTextObject*   *<plug>KrlTxtObjInnerFunc*
                                              *<plug>KrlTxtObjAroundFuncExclCo*
                                              *<plug>KrlTxtObjAroundFuncInclCo*
g:krlFunctionTextObject:
------------------------

Note: These text objects depend on |g:krlMoveAroundKeyMap| = 1 or omitted.

    `if`: inner part of def/deffct.
    `af`: outer part of def/deffct.
    `aF`: outer part of def/deffct including, if present, one empty following
        line and directly preceding comments.

To force these text objects if `if`, `af` and/or `aF` is already mapped: >
    let g:krlFunctionTextObject = 1

Alternativ <plug> mappings: >
    augroup KrlFuncTextObj
    au!
    au FileType krl xmap <silent><buffer> ANYKEY <Plug>KrlTxtObjAroundFuncInclCo
    au FileType krl omap <silent><buffer> ANYKEY <Plug>KrlTxtObjAroundFuncInclCo
    au FileType krl xmap <silent><buffer> SOMEKEY <Plug>KrlTxtObjAroundFuncExclCo
    au FileType krl omap <silent><buffer> SOMEKEY <Plug>KrlTxtObjAroundFuncExclCo
    au FileType krl xmap <silent><buffer> OTHERKEY <Plug>KrlTxtObjInnerFunc
    au FileType krl omap <silent><buffer> OTHERKEY <Plug>KrlTxtObjInnerFunc
    augroup END


Index: |krl-index|
                        *g:krlFoldTextObject*   *<plug>KrlTxtObjInnerFold*
                                              *<plug>KrlTxtObjAroundFold*
g:krlFoldTextObject:
--------------------

Note: These text objects depend on |matchit|. See |matchit-install|.

    [count]`io`: inner part of a fold. Takes a count for nested folds.
    [count]`ao`: outer part of a fold. Takes a count for nested folds.

To force these text objects if `io` and/or `ao` is already mapped: >
    let g:krlFoldTextObject = 1

Alternativ <plug> mappings: >
    augroup KrlFoldTextObj
    au!
    au FileType krl xmap <silent><buffer> ANYKEY <Plug>KrlTxtObjAroundFold
    au FileType krl omap <silent><buffer> ANYKEY <Plug>KrlTxtObjAroundFold
    au FileType krl xmap <silent><buffer> SOMEKEY <Plug>KrlTxtObjInnerFold
    au FileType krl omap <silent><buffer> SOMEKEY <Plug>KrlTxtObjInnerFold
    augroup END


Index: |krl-index|
==============================================================================
                        *krl-formatting-comments*
==============================================================================
                        *g:krlAutoComment*
g:krlAutoComment:
-----------------

Disable 'formatoptions' += ro. See |fo-table|: >
    let g:krlAutoComment = 0

If omitted or set to 1 the comment char ; is automatically added after
hitting |i_<CR>|, |o| or |O| on a comment line.  


Index: |krl-index|
                        *g:krlFormatComments*
g:krlFormatComments:
--------------------

Disable 'formatoptions' -= t and += lj. See |fo-table|. >
    let g:krlFormatComments = 0

If omitted or set to 1 comments get wrapped at 'textwidth'. If 'textwidth' is
0 it's set to 54 which matches a KCP screen. You may also use |gq| to format
comments.


Index: |krl-index|
==============================================================================
                        *krl-auto-form*

With krl-for-vim you can quickly create a new DEF, DEFFCT or DEFDAT after your
liking. 

Type <leader>n anywhere in a *.src, *.sub or *.dat file. You will get prompted
on some details for the new body. The last prompt is the name. The name prompt
is mandatory, all others may be typed quickly after <leader>n. Hit <esc> or
enter an empty string at any prompt to abort.

Example: <leader>ngfb will insert a body for a new global function of type
bool.
Mnemonic: New Global Function of type Bool

If the type does not match the current file type (*.src, *.sub or *.dat), a
a new file with the given name is created. In case you want a new DEFDAT in a
*.src or vice versa.

The User group |autocmd-event| `KrlAutoFormPost` will be triggered after the
insertion is finished and may be used for further customization: >
    augroup KrlAutoForm
    au!
    au User KrlAutoFormPost call MyAutoFormPostFunc()
    augroup END

Index: |krl-index|
==============================================================================
                        *g:krlAutoFormKeyMap*
g:krlAutoFormKeyMap:
--------------------

To force these mappings if `<leader>n` is already mapped: >
    let g:krlAutoFormKeyMap = 1

This list may seem overwhelming, but those mappings are quite logical and can
be used to skip the first few promps. After <leader>n just continue like you
would answer the prompts for "[g]lobal or [l]ocal?", "[d]ef, def[f]ct or
defd[a]t?" and "Datatype? [b]ool, [i]nt, [r]eal...".

Note: Mappings marked with * will have a little delay until they trigger.

  `<leader>n`:     New prompted body *
  `<leader>nn`:    New prompted body
  
  `<leader>nl`:    New Local prompted body *
  `<leader>nll`:   New Local prompted body
  
  `<leader>nla`:   New Local defdAt body
  `<leader>nld`:   New Local Def body
  `<leader>nlf`:   New Local defFct with prompted type *
  `<leader>nlfu`:  New Local defFct with prompted type
  
  `<leader>nlfb`:  New Local defFct of type Bool
  `<leader>nlfi`:  New Local defFct of type Integer
  `<leader>nlfr`:  New Local defFct of type Real
  `<leader>nlfc`:  New Local defFct of type Char
  `<leader>nlff`:  New Local defFct of type Frame
  `<leader>nlfp`:  New Local defFct of type Pos
  `<leader>nlf6`:  New Local defFct of type e6pos
  `<leader>nlfa`:  New Local defFct of type Axis
  `<leader>nlfx`:  New Local defFct of type e6aXis
  
  `<leader>na`:    New local defdAt body
  `<leader>nd`:    New local Def body
  `<leader>nf`:    New local defFct with prompted type *
  `<leader>nfu`:   New local defFct with prompted type
  
  `<leader>nfb`:   New local defFct of type Bool
  `<leader>nfi`:   New local defFct of type Integer
  `<leader>nfr`:   New local defFct of type Real
  `<leader>nfc`:   New local defFct of type Char
  `<leader>nff`:   New local defFct of type Frame
  `<leader>nfp`:   New local defFct of type Pos
  `<leader>nf6`:   New local defFct of type e6pos
  `<leader>nfa`:   New local defFct of type Axis
  `<leader>nfx`:   New local defFct of type e6aXis
  
  `<leader>ng`:    New Global prompted body *
  `<leader>ngg`:   New Global prompted body
  
  `<leader>nga`:   New Global defdAt body
  `<leader>ngd`:   New Global Def body
  `<leader>ngf`:   New Global defFct with prompted type *
  `<leader>ngfu`:  New Global defFct with prompted type
  
  `<leader>ngfb`:  New Global defFct of type Bool
  `<leader>ngfi`:  New Global defFct of type Integer
  `<leader>ngfr`:  New Global defFct of type Real
  `<leader>ngfc`:  New Global defFct of type Char
  `<leader>ngff`:  New Global defFct of type Frame
  `<leader>ngfp`:  New Global defFct of type Pos
  `<leader>ngf6`:  New Global defFct of type e6pos
  `<leader>ngfa`:  New Global defFct of type Axis
  `<leader>ngfx`:  New Global defFct of type e6aXis

                        *<Plug>KrlAutoForm*
Alternativ <plug> mappings: >
    augroup KrlAutoFormMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY01 <Plug>KrlAutoForm
    au FileType krl nmap <silent><buffer> ANYKEY02 <Plug>KrlAutoFormLocalDat       
    au FileType krl nmap <silent><buffer> ANYKEY03 <Plug>KrlAutoFormLocalDef       
    au FileType krl nmap <silent><buffer> ANYKEY04 <Plug>KrlAutoFormLocalFct       
    au FileType krl nmap <silent><buffer> ANYKEY05 <Plug>KrlAutoFormLocalFctBool   
    au FileType krl nmap <silent><buffer> ANYKEY06 <Plug>KrlAutoFormLocalFctInt    
    au FileType krl nmap <silent><buffer> ANYKEY07 <Plug>KrlAutoFormLocalFctReal   
    au FileType krl nmap <silent><buffer> ANYKEY08 <Plug>KrlAutoFormLocalFctChar   
    au FileType krl nmap <silent><buffer> ANYKEY09 <Plug>KrlAutoFormLocalFctFrame  
    au FileType krl nmap <silent><buffer> ANYKEY10 <Plug>KrlAutoFormLocalFctPos    
    au FileType krl nmap <silent><buffer> ANYKEY11 <Plug>KrlAutoFormLocalFctE6Pos  
    au FileType krl nmap <silent><buffer> ANYKEY12 <Plug>KrlAutoFormLocalFctAxis   
    au FileType krl nmap <silent><buffer> ANYKEY13 <Plug>KrlAutoFormLocalFctE6Axis 
    au FileType krl nmap <silent><buffer> ANYKEY14 <Plug>KrlAutoFormGlobalDat      
    au FileType krl nmap <silent><buffer> ANYKEY15 <Plug>KrlAutoFormGlobalDef      
    au FileType krl nmap <silent><buffer> ANYKEY16 <Plug>KrlAutoFormGlobalFct      
    au FileType krl nmap <silent><buffer> ANYKEY17 <Plug>KrlAutoFormGlobalFctBool  
    au FileType krl nmap <silent><buffer> ANYKEY18 <Plug>KrlAutoFormGlobalFctInt   
    au FileType krl nmap <silent><buffer> ANYKEY19 <Plug>KrlAutoFormGlobalFctReal  
    au FileType krl nmap <silent><buffer> ANYKEY20 <Plug>KrlAutoFormGlobalFctChar  
    au FileType krl nmap <silent><buffer> ANYKEY21 <Plug>KrlAutoFormGlobalFctFrame 
    au FileType krl nmap <silent><buffer> ANYKEY22 <Plug>KrlAutoFormGlobalFctPos   
    au FileType krl nmap <silent><buffer> ANYKEY23 <Plug>KrlAutoFormGlobalFctE6Pos 
    au FileType krl nmap <silent><buffer> ANYKEY24 <Plug>KrlAutoFormGlobalFctAxis  
    au FileType krl nmap <silent><buffer> ANYKEY25 <Plug>KrlAutoFormGlobalFctE6Axis
    augroup END


Index: |krl-index|
                        *g:krlPathToBodyFiles*
g:krlPathToBodyFiles:
---------------------

Enable use of custom body files. Set to a valid path, e.g.: >
    let g:krlPathToBodyFiles='~/.vim/mykrlresource/'
    let g:krlPathToBodyFiles='c:\user\me\krlresource\'
    let g:krlPathToBodyFiles='$USERPROFILE\krl_skel\'

If omitted or no file were found in the given path a default bodies will be
inserted.

You may put one or more of the following files into this folder: >
    def.src
    deffct.src
    defdat.dat

Those files should contain your custom body for a DEF, DEFFCT and/or DEFDAT.

Example def.src:  >
    <global>def <name>()
      ;
      <|>
      ;
    end ; <name>()

Example deffct.src:  >
    ; ===========================================================
    ; NAME:         <name>()
    ; USAGE:        <|>
    ; DESCRIPTION:  
    ; PARAMETERS:   
    ; RESULT:       <datatype> value ...
    ; NOTES:        
    ; ===========================================================
    <global>deffct <datatype> <name>()
      decl <datatype> <returnvar>
      
      
      return <returnvar>
    endfct

Example defdat.dat:  >
    &ACCESS RVO
    &REL 1
    &COMMENT <name>
    defdat <name><global>
    decl basis_sugg_t LAST_BASIS={POINT1[] "P10                     ",POINT2[] "P20                     ",CP_PARAMS[] "CPDAT10                 ",PTP_PARAMS[] "PDAT10                  ",CONT[] "                        ",CP_VEL[] "2                       ",PTP_VEL[] " 100                    ",SYNC_PARAMS[] "SYNCDAT                 ",SPL_NAME[] "S10                     "}
    
    <|>
    enddat

Note the <Markers> in the example body files. Markers have to be put in
<>. Any marker but | may be present multiple times or omitted.
Markers:  global    substituted with "global " (or " public" if defdat) or ""
          name      substituted with entered name
          type      substituted with "def", "deffct" or "defdat"
          datatype  substituted with the chosen data type
          returnvar substituted with a varname in the form of [prefix]Result
          |         put cursor here when finished

Note that comments or anything below the END line is not supported and may
have unexpected results!


Index: |krl-index|
                        *g:krlAutoFormUpperCase*
g:krlAutoFormUpperCase:
-----------------------

Enable conversion of auto form to upper case:  >
    let g:krlAutoFormUpperCase = 1

If omitted or set to 0 character case of inserted bodies is left as is.


Index: |krl-index|
==============================================================================
                        *krl-known-bugs*  
==============================================================================
                        *krl-indent-bugs*
Known bugs in |krl-indent|:
-------------------------
1. If a subroutine is named so that it starts with a keyword that will
    decrease the level of indention, then the call is indeted accordingly.
    You can fix this quickly by hitting |i_CTRL-F| while still in insert mode 
    after you finished the complete call, or use |i_CTRL-P| or |i_CTRL-N| before 
    the keyword is complete which causes the indention.

    Keywords that decrease the level of indention are: 
    end*, else, case, default, until and continue.
    "continue" only decreases if the next line is one of the other mentioned 
    keywords.

    Example: If a subroutine is called CaseHandling1() you must either type:
    CaseHandling1()^F
    or:
    Cas^P()
    The latter only works if the name already exist anywhere in the
    files you have in buffer.

    Once the call CaseHandling1() is fully present and you are back in
    Normal mode you can use |=| to fix the indention.

2. A continue belongs to the following line, so I want it
    to have the same indention as the following line:

    Example: 
    repeat
      stuff()
    continue
    until $in[1]

    Now, if the following "until" does not yet exist, "continue" will be
    indented like the previous line. |=||k| in normal mode after typing "until"
    will fix this.


Index: |krl-index|
                        *krl-highlight-bugs*
Known bugs in |krl-highlighting|:
-------------------------------
1. If a frame is called "in" or "out" (like DECL FRAME In = {X ...) and used
    in an operation with ":" (OutFrame = base_data[1]:In) it is
    highlighted like the ":IN" from "DEF FOO(nInPara:IN)".
2. If a keyword is used as structure component name you may get false
    highlighting.


Index: |krl-index|
                        *krl-go-definition-bugs*
Known bugs in |g:krlGoDefinitionKeyMap|:
--------------------------------------
1. You can use the modified `gd` also on user defined ENUM or STRUC names. 
    You may get a false positives on a variable definition which uses this
    data type. The correct result, if present in path, will still be shown.


Index: |krl-index|

vim:tw=78:ts=4:et:sw=4:ft=help:norl:
