*krl.txt*	Kuka Robot Language for Vim version 7.4	Last change: 2019 Mar 11


		  VIM REFERENCE MANUAL    by Patrick Meiser-Knosowski
					  <knosowski@graeff.de>



Installation:
-------------

Extract the most recent release and copy the folders 
`/doc`, `/ftdetect`, `/ftplugin`, `/indent` and `/syntax` 
into your `~/.vim/` or `%USERPROFILE%\vimfiles\` directory. 
Overwrite krl.* files from older installation. 

To use these plugins put >
    filetype plugin indent on
    syntax on
in your .vimrc.

You may have to run >
    :helptags ~/.vim/doc/
or >
    :helptags ~/vimfiles/doc/
to use the help within Vim after installation. >
    :help krl



==============================================================================
                        *krl*
                        *krl-index* 
krl help index:
---------------
|krl-Introducion|
|krl-options| and <plug> mappings
|krl-folding|
|krl-highlighting|
|krl-indent|
|krl-auto-form|
|krl-keyword-chars|
|krl-jump-quickly|
|krl-matchit-support|
|krl-formatting-comments|
|krl-known-bugs|
  |krl-indent-bugs|
  |krl-highlight-bugs|
  |krl-go-definition-bugs|



==============================================================================
                        *krl-Introducion*
Introducion:
------------

KRL for Vim (7.4 or later) is a collection of Vim scripts to help programing
KUKA industrial robots. 

It provides
* syntax highlighting,
* auto indention,
* folding,
* mappings and settings to navigate through code in a backup folder structure,
* Text objects for functions and folds and
* mappings to insert a body of a new DEF, DEFFCT or DEFDAT based on user 
  defined templates or hopefully sane defaults.

Have a look at |krl-tl:dr| to get a quick overview over the most important
options provided by KRL for Vim.

Since version 2.0.0 most features are enabled by default, so you don't need
that many options in your .vimrc. Existing mappings don't get overridden,
unless the corrosponding option is explicitly set. There are <plug>-mappings
available too, if you prefere different key bindings.

KRL for Vim supports viewing and analysing VKRC files. Folding will get
optimized for VKRC and you can use your Go Definition mapping (default gd) on
a SPSMAKRO, UP, bin, binin or Marker in a fold line. However, this is NOT a
VKRC-Editor.

Note: Keep your files to be edited in one folder or in a regular robot
backup folder structure. KRL for Vim modifies 'path' accordingly. Since
version 2.0.0 KRC1 backups are supported too.
Note to linux users: Keep your files to be edited on a FAT file system. 
Some features need the case insensitive file system to work properly.


                        *krl-tl:dr*
Short options description:
--------------------------
Q: Since version 2.0.0 everything's weird. How so?
A: Most optional features are enabled by default now.

Q: I'm here to feed my kids, not to read. How do I get rid of stuff?  
A: Disable stuff in your |.vimrc| (see |krl-options| for details): >

    let g:krlKeyWord = 0 " don't treat $, # and & as word
    let g:krlAutoComment = 0 " don't continue comments with o, O or Enter
    let g:krlFormatComments = 0 " don't break comment lines
    let g:krlPath = 0 " don't change 'path'
    let g:krlSpaceIndent = 0 " don't change 'sts', 'sw', 'et' and 'sr'
    let g:knopShortenQFPath = 0 " don't shorten paths in quickfix

Q: Which keys get mapped to what?
A: If there is no existing mapping which would be overridden and no plug
    mapping is configured for that function then the following keys get
    mapped: >

    <F2> Open all folds.
    <F3> Close movement folds.
    <F4> Close all folds.
            Depend on g:krlFoldLevel not existing or >=1.
            Can be forced with
        let g:krlFoldingKeyMap = 1

    gd Go to or show definition of variable or def/deffct.
            Can be forced with
        let g:krlGoDefinitionKeyMap = 1

    <leader>u List all appearances of word under cursor outside a comment,
            string or enum declaration.
            Can be forced with
        let g:krlListUsageKeyMap = 1

    <leader>f List all def/deffct in the current file.
            Can be forced with
        let g:krlListDefKeyMap = 1

    [[ Move around functions. Takes a count.
    ]] Move around functions. Takes a count.
    [] Move around functions. Takes a count.
    ][ Move around functions. Takes a count.
    [; Move around comments. Takes a count.
    ]; Move around comments. Takes a count.
            Will override existing mappings!
            Can be forced off with
        let g:krlMoveAroundKeyMap = 0

    if Inner function text object.
    af Around function text object.
    aF Around function text object including preceding comments and one
        following empty line.
            Depend on g:krlMoveAroundKeyMap not existing or =1.
            Can be forced with
        let g:krlFunctionTextObject = 1

    io Inner fold text object. Takes a count for nested folds.
    ao Around fold text object. Takes a count for nested folds.
            Depend on matchit.
            Can be forced with 
        let g:krlFoldTextObject = 1

    <leader>n Inserts a new def/deffct.
            Can be forced with
        let g:krlAutoFormKeyMap = 1

Q: Scrolling feels sluggish. What can I do?
A: Switch error highlighting off and/or folding to marker: >

    let g:krlFoldMethodSyntax = 0 " better performance, but case sensitive
    let g:krlShowError = 0        " better performance

Q: Still sluggish!
A: Switch syntax off or jump instead of scroll! >

Q: Where are the nice and informative messages?
A: :let g:knopVerbose=1 any time.


                        *krl-content*
Content description:
--------------------
>
    ~/.vim/doc/krl.txt
    ~/.vim/ftdetect/krl.vim
    ~/.vim/ftplugin/krl.vim
    ~/.vim/indent/krl.vim
    ~/.vim/syntax/krl.vim

You may use all these independently from one another. Just don't mix versions
of different releases. Some features may work better when all files are loaded.

~/.vim/doc/krl.txt
Help file. This should help you to use these plugins to your best advantage.
Requires >
    :helptags ~/.vim/doc

~/.vim/ftdetect/krl.vim
Detects KRL files based on their file name ending and content. KRL files are 
checked for the presence of a DEF* line or any &HEADER.
Requires >
    :filetype on

~/.vim/ftplugin/krl.vim
Sets various Vim options and provides key mappings and folding. It supports
commentary (vimscript #3695) and matchit (vimscript #39).
Requires >
    :filetype plugin on

~/.vim/indent/krl.vim
Sets indent related Vim options. Sets indention to 2 spaces by default,
optional.  
Requires >
    :filetype indent on

~/.vim/syntax/krl.vim
Does make life more colorful. Unfortunately some features of the other files
may work better with syntax on. This should not stop you from trying syntax
off if you like.  
Requires >
    :syntax on



==============================================================================
                        *krl-options*
krl options:
------------

Optional key mappings:
Also see these options for alternative <PLUG> mappings.
|g:krlFoldingKeyMap|        <F2> to <F4> changes folding
|g:krlGoDefinitionKeyMap|   gd to see declaration of word under cursor
|g:krlListUsageKeyMap|      <leader>u lists all appearances of current word
|g:krlListDefKeyMap|        <leader>f lists def/deffct of current file
|g:krlMoveAroundKeyMap|     [[, ]] ... jumps around def/deffct
|g:krlFunctionTextObject|   if, af and aF def/deffct text objects
|g:krlFoldTextObject|       io and ao fold text objects
|g:krlAutoFormKeyMap|       <leader>n inserts body for def, deffct or defdat
Options to enable/disable features:
Highlight
|g:krlNoHighLink|           Adds krl secific |group-name|s
|g:krlShowError|            Highlighting of syntax errors
Indent
|g:krlCommentIndent|        ... indention of first column comments
|g:krlSpaceIndent|          Leave 'sts', 'sw', 'et' and 'sr' untouched
Fold
|g:krlFoldLevel|            Folding behavior
|g:krlFoldMethodSyntax|     Fold method syntax or marker
Comments
|g:krlAutoComment|          Auto insert ; when hitting i_<CR> , |o| or |O|
|g:krlFormatComments|       Line break for comment lines
Auto form
|g:krlPathToBodyFiles|      Enables custom body files for auto form
|g:krlAutoFormUpperCase|    Convert auto form to upper case
quickfix
|g:knopShortenQFPath|       Shorten paths in quickfix
|g:knopRhsQuickfix|         Open quickfix right hand side
|g:knopLhsQuickfix|         Open quickfix left hand side
Other
|g:krlKeyWord|              Don't include $, # and & in 'iskeyword'
|g:krlPath|                 Leave 'path' untouched
|g:knopVerbose|             Switch on verbose messages


Index: |krl-index|
                        *g:krlCloseFolds*
g:krlCloseFolds:
----------------
Used in ~/.vim/ftplugin/krl.vim

Set this option to 1 makes closing all folds the starting behavior of this
plugin.  >
    let g:krlCloseFolds = 1

Set this option to 2 to switch folding off completely.  >
   let g:krlCloseFolds = 2

NOTE limitation: See |krl-folding|.

Default is closing only movement folds in regular KRC files and closing all
folds in VKRC files. See also |krl-folding|.


Index: |krl-index|
                        *g:krlFoldKeyMap*          *<Plug>KrlCloseAllFolds*
                        *<Plug>KrlCloseLessFolds*  *<Plug>KrlCloseNoFolds*
g:krlFoldKeyMap:
----------------
Used in ~/.vim/ftplugin/krl.vim

Note: This only works if |g:krlCloseFolds| is unequal 2. 

This option adds both key mappings for 
    <F2>: Close only krl standard movement folds and
    <F3>: Close all folds. >
    let g:krlFoldKeyMap = 1

Alternativ <plug> mappings: >
    augroup KrlFoldMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlCloseAllFolds
    au FileType krl nmap <silent><buffer> SOMEKEY <Plug>KrlCloseLessFolds
    au FileType krl nmap <silent><buffer> OTHERKEY <Plug>KrlCloseNoFolds
    augroup END

Default is no mapping. See also |krl-folding|.


Index: |krl-index|
                        *g:krlMoveAroundKeyMap*
g:krlMoveAroundKeyMap:
----------------------
Used in ~/.vim/ftplugin/krl.vim

Note: This option changes the default vim commands |[[|, |]]|, |[]| and |][|!

This option adds the following key mappings for [[, ]], [], ][, [; and ]; >
    let g:krlMoveAroundKeyMap = 1

[count][[    Jumps backward to the next DEF, DEFDAT or DEFFCT. If [count]
             is given jumps [count] times. Works in |normal-mode| and in
             |Visual|-mode. This does respect 'wrapscan' unless started in
             Visual-mode. 

[count]]]    Like [[ but jumps forward to the next DEF, DEFDAT or DEFFCT.

[count][]    Like [[ but jumps backward to the next END, ENDDAT or ENDFCT.

[count]][    Like [[ but jumps forward to the next END, ENDDAT or ENDFCT.

[count][;    Like [[ but jumps backward to the start of current or previous
             comment.

[count]];    Like [[ but jumps forward to the end of the current or the
             next comment.

Default is no mapping. See also |krl-jump-quickly|.


Index: |krl-index|
                        *g:krlListDefKeyMap*    *<Plug>KrlListDef*
g:krlListDefKeyMap:
-------------------
Used in ~/.vim/ftplugin/krl.vim

This option adds a mapping to <leader>f to list all DEFs and DEFFCTs of the
current file in the |qickfix|-list. >
    let g:krlListDefKeyMap = 1

Mnemonic: List Functions

Alternativ <plug> mapping: >
    augroup KrlListDefMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlListDef
    augroup END

Default is no mapping. See also |krl-jump-quickly|.


Index: |krl-index|
                        *g:krlGoDefinitionKeyMap*   *<Plug>KrlGoDef*
g:krlGoDefinitionKeyMap:
------------------------
Used in ~/.vim/ftplugin/krl.vim

Note: This option changes the default vim command |gd|.

This option adds a key mapping to the sequence |gd| to jump quickly to
variable- or DEF/DEFFCT-declarations. >
    let g:krlGoDefinitionKeyMap = 1

Mnemonic: Go Definition

If the declaration is outside the current file the |qickfix|-list will open. 

To find global declarations, your current file must lives in a regular backup
folder structure (below the `/KRC` folder) and 'path' must be set properly.
ftplugin/krl.vim does set 'path' for you, unless you set |g:krlNoPath|.

Works best with :syntax on and both |g:krlNoPath| and |g:krlNoKeyWord| omitted
or 0.

Alternativ <plug> mapping: >
    augroup KrlGoDefMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlGoDef
    augroup END

Limitations: You may get a false positive if you use gd on a data type which
is not defined as STRUC. See |krl-go-definition-bugs|.

Default is no mapping. See also |krl-jump-quickly|.


Index: |krl-index|
                        *g:krlListUsageKeyMap*  *<Plug>KrlListUse*
g:krlListUsageKeyMap:
---------------------
Used in ~/.vim/ftplugin/krl.vim

This option adds a mapping to <leader>u to list all appearances (outside of
strings and comments) of the word under the cursor in the |qickfix|-list. >
    let g:krlListUsageKeyMap = 1

Mnemonic: List Usage

Alternativ <plug> mapping: >
    augroup KrlListUseMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlListUse
    augroup END

Default is no mapping. See also |krl-jump-quickly|.


Index: |krl-index|
                        *g:krlAutoFormKeyMap*   *<Plug>KrlAutoForm*
g:krlAutoFormKeyMap:
--------------------
Used in ~/.vim/ftplugin/krl.vim

This option adds several mappings starting with <leader>n to insert a body for
a new DEF, DEFFCT or DEFDAT into the current file (or even a new file). >
    let g:krlAutoFormKeyMap = 1

Mappings marked with * will have a little delay until they trigger.

  <leader>n     New prompted body *
  <leader>nn    New prompted body

The following list may seem overwhelming, but those mappings are quite logical
and can be used to skip the first few promps. After <leader>n just continue
like you would answer the promps for "[g]lobal or [l]ocal?", "[d]ef, def[f]ct
or defd[a]t?" and "Datatype? [b]ool, [i]nt, [r]eal..."

  <leader>nl    New Local prompted body *
  <leader>nll   New Local prompted body
  
  <leader>nla   New Local defdAt body
  <leader>nld   New Local Def body
  <leader>nlf   New Local defFct with prompted type *
  <leader>nlfu  New Local defFct with prompted type
  
  <leader>nlfb  New Local defFct of type Bool
  <leader>nlfi  New Local defFct of type Integer
  <leader>nlfr  New Local defFct of type Real
  <leader>nlfc  New Local defFct of type Char
  <leader>nlff  New Local defFct of type Frame
  <leader>nlfp  New Local defFct of type Pos
  <leader>nlf6  New Local defFct of type e6pos
  <leader>nlfa  New Local defFct of type Axis
  <leader>nlfx  New Local defFct of type e6aXis
  
  <leader>na    New local defdAt body
  <leader>nd    New local Def body
  <leader>nf    New local defFct with prompted type *
  <leader>nfu   New local defFct with prompted type
  
  <leader>nfb   New local defFct of type Bool
  <leader>nfi   New local defFct of type Integer
  <leader>nfr   New local defFct of type Real
  <leader>nfc   New local defFct of type Char
  <leader>nff   New local defFct of type Frame
  <leader>nfp   New local defFct of type Pos
  <leader>nf6   New local defFct of type e6pos
  <leader>nfa   New local defFct of type Axis
  <leader>nfx   New local defFct of type e6aXis
  
  <leader>ng    New Global prompted body *
  <leader>ngg   New Global prompted body
  
  <leader>nga   New Global defdAt body
  <leader>ngd   New Global Def body
  <leader>ngf   New Global defFct with prompted type *
  <leader>ngfu  New Global defFct with prompted type
  
  <leader>ngfb  New Global defFct of type Bool
  <leader>ngfi  New Global defFct of type Integer
  <leader>ngfr  New Global defFct of type Real
  <leader>ngfc  New Global defFct of type Char
  <leader>ngff  New Global defFct of type Frame
  <leader>ngfp  New Global defFct of type Pos
  <leader>ngf6  New Global defFct of type e6pos
  <leader>ngfa  New Global defFct of type Axis
  <leader>ngfx  New Global defFct of type e6aXis

Alternativ <plug> mappings: >
    augroup KrlAutoFormMapping
    au!
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoForm
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalDat       
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalDef       
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFct       
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctBool   
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctInt    
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctReal   
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctChar   
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctFrame  
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctPos    
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctE6Pos  
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctAxis   
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormLocalFctE6Axis 
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalDat      
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalDef      
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFct      
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctBool  
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctInt   
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctReal  
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctChar  
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctFrame 
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctPos   
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctE6Pos 
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctAxis  
    au FileType krl nmap <silent><buffer> ANYKEY <Plug>KrlAutoFormGlobalFctE6Axis
    augroup END

Default is no mapping. See also |krl-auto-form|.


Index: |krl-index|
                        *g:krlPathToBodyFiles*
g:krlPathToBodyFiles:
---------------------
Used in ~/.vim/ftplugin/krl.vim

Set this option to a valid path to a folder with copys of your body files. >
    let g:krlPathToBodyFiles='~/.vim/mykrlresource/'
    let g:krlPathToBodyFiles='c:\user\me\krlresource\'
    let g:krlPathToBodyFiles='$USERPROFILE\krl_skel\'

You may put one or more of the following files into this folder:
  def.src
  deffct.src
  defdat.dat

Default is no use of custom body files. See also |krl-auto-form|.


Index: |krl-index|
                        *g:krlAutoFormUpperCase*
g:krlAutoFormUpperCase:
-----------------------
Used in ~/.vim/ftplugin/krl.vim

This option enables conversion of the auto form insertions to upper case.  >
    let g:krlAutoFormUpperCase = 1

Default is no conversion to upper case. See also |krl-auto-form|.


Index: |krl-index|
                        *g:krlRhsQuickfix*   *g:krlLhsQuickfix*
g:krlRhsQuickfix and g:krlLhsQuickfix:
--------------------------------------
Used in ~/.vim/ftplugin/krl.vim

These options changes where ftplugin/krl.vim opens the |quickfix-window| the
first time, when using a mapping from |krl-jump-quickly|.

Open quickfix-window right hand side: >
    let g:krlRhsQuickfix = 1

Open quickfix-window left hand side: >
    let g:krlLhsQuickfix = 1

These two options are a synonym for g:knopRhsQuickfix and g:knopLhsQuickfix.
You may use g:knop[RL]hsQuickfix instead, if you want the same behavior in
rapid.vim (vimscript #5348) as well.

NOTE: If you use |vim-qf|.vim (vimscript #5211) then these options will not work
unless g:|qf_window_bottom| is 0: >
    let g:qf_window_bottom = 0

Default is vim default position of quickfix window. See also
|krl-jump-quickly|.


Index: |krl-index|
                        *g:krlNoHighlight*    *g:krlNoHighLink*
g:krlNoHighLink:
----------------
Used in ~/.vim/syntax/krl.vim

With this option set krl.vim does not |hi-link| krlBuildInFunction to
|group-name| Function, krlContinue to Statement and krlMovement to Special. >
    let g:krlNoHighLink = 1

This is usefull if you want to set your own colors for the colorscheme groups
Sysvars, Movement, Continue and/or BuildInFunction. With this option set you
may use your own colors for KSS variables beginning with $, movement
instructions, CONTINUE instructions and/or KSS functions like this:  >
    highlight Sysvars           guibg=Black     guifg=white
    highlight BuildInFunction   guibg=Black     guifg=#00d5d5
    highlight Continue          guibg=black     guifg=#646423
    highlight Movement          guibg=black     guifg=green

Set this option to 1 if you use colorscheme tortus.vim.  

Default is: >
    highlight link krlBuildInFunction Function
    highlight link krlContinue Statement
    highlight link krlMovement Special
    highlight link krlSysvars Sysvars

See also |krl-highlighting|.


Index: |krl-index|
                        *g:krlShowError*
g:krlShowError:
---------------
Used in ~/.vim/syntax/krl.vim

This option enables the highlighting for some more or less common typos.  >
    let g:krlShowError = 1

If enabled a few false usages of =, ==, <= and >= are highlighted as
|group-name| Error. Note that this is not a syntax check. I have found no 
occurrence of false positives, but it's disabled by default just in case.

|g:krlShowError| has no effect if |syntax| is off.

Default is no highlighting of syntax errors. See also |krl-highlighting|.


Index: |krl-index|
                        *g:krlFormatComments*
g:krlFormatComments:
--------------------
Used in ~/.vim/ftplugin/krl.vim

This option changes 'formatoptions' and 'textwidth' so that lines starting
with ";" get wrapped to match on a teach pendant screen when entered. >
    let g:krlFormatComments = 1

Note: If 'textwidth' already has a value unequal 0, only 'formatoptions' is
changed and textwidth is left untouched. 

Default settings are no change of textwidth and formatoptions. Changed values
are: >
    setlocal textwidth=52
    setlocal formatoptions-=t
    setlocal formatoptions+=l
    setlocal formatoptions+=j

See also |fo-table| and |krl-formatting-comments|.


Index: |krl-index|
                        *g:krlAutoComment*
g:krlAutoComment:
-----------------
Used in ~/.vim/ftplugin/krl.vim

This option changes 'formatoptions'. It enables automatic insertion of line 
comment char ";" after hitting i_<CR> , |o| or |O| on a comment line.  >
    let g:krlAutoComment = 1

Default settings are no change of 'formatoptions'. Changed values are: >
    setlocal formatoptions+=r
    setlocal formatoptions+=o

See also |fo-table| and |krl-formatting-comments|.


Index: |krl-index|
                        *g:krlNoIndent*
g:krlNoIndent:
--------------
Used in ~/.vim/indent/krl.vim

This option stopps ~/.vim/indent/krl.vim from being loaded and will disable
krl indent. >
    let g:krlNoIndent = 1

This does work the same as |b:did_indent| |30.3|.

Default is indention enabled. See also |krl-indent|.


Index: |krl-index|
                        *g:krlNoSpaceIndent*
g:krlNoSpaceIndent:
-------------------
Used in ~/.vim/indent/krl.vim

This option disables the modification of 'softtabstop', 'expandtab', 
'shiftwidth' and 'shiftround'.  >
    let g:krlNoSpaceIndent = 1

Keep in mind that space is rare and tabs look really awful on the teach
pendant.

Default settings are: >
    setlocal softtabstop = 2
    setlocal shiftwidth = 2
    setlocal expandtab
    setlocal shiftround

See also |krl-indent|.


Index: |krl-index|
                        *g:krlNoKeyWord*
g:krlNoKeyWord:
---------------
Used in ~/.vim/ftplugin/krl.vim

This option disables the inclusion of #, & and $ into 'iskeyword'.  >
    let g:krlNoKeyWord = 1

Default settings are: >
    setlocal iskeyword+=#,$,&

See also |krl-keyword-chars|.


Index: |krl-index|
                        *g:krlNoPath*
g:krlNoPath:
------------
Used in ~/.vim/ftplugin/krl.vim

This option disables the modification of 'path'. >
    let g:krlNoPath = 1

By default krl.vim does set 'path' to find files in a regular KUKA backup
folder structure.

KRC/
  |-R1/
  |  |-Mada/
  |  |-Program/
  |  |-System/
  |  |-TP/
  |-STEU/
       |-Mada/

krl.vim does set 'path' based on the default setting. See 'path' for details.
krl.vim adds './**' to this. See |starstar|.
Furthermore krl.vim looks up to 6 levels upward for a KRC/ folder. If found
the folder does get added to path with ** appended.
If no KRC/ folder was found krl.vim looks up to 5 levels upward for R1/ and
STEU/ folders. If found the folders get added to path with ** appended.
If no R1/ folder was found krl.vim looks up to 4 levels upward for Program/,
System/, Mada/ and TP/ folders. If found the folders get added to path with **
appended.

See also |krl-jump-quickly|.


Index: |krl-index|
                        *g:krlNoVerbose*
g:krlNoVerbose:
---------------
Used in ~/.vim/ftplugin/krl.vim

This option disables all verbose messages generated by ftplugin/krl.vim. >
    let g:krlNoVerbose = 1

This option is a synonym for g:knopNoVerbose. You may use g:knopNoVerbose 
instead, if you want the same behavior in rapid.vim (vimscript #5348) as well.

Default is messages on. See also |krl-jump-quickly|.



Index: |krl-index|
==============================================================================
                        *krl-folding*
krl folding:
------------
You may have to put >
    filetype plugin on
into your .vimrc to use krl folding.

Related krl options
  |g:krlFoldKeyMap|
  |g:krlCloseFolds|

See |zo|, |zc|, |zR| and |zM| as well as other |fold-commands| for help with
folds in vim.

By default krl.vim closes only movement folds in regular KRL files and closes
all folds in VKRC files. See Limitations below.

You may set |g:krlCloseFolds| to change the default behavior to closing every
fold. You can switch krl folding off there as well.

There is also a key mapping available if |g:krlFoldKeyMap| is set.

NOTE Limitations: 
1. Folds only work if upper case: >
    FOLD/ENDFOLD

2. Movement folds depend on %CMOVE present in the ;FOLD line: >
    %CMOVE/ENDFOLD

3. For VKRC files like Folge, Makro and UP only closing all or no fold works.
    That's because of nested regular folds in movement folds, so the matching
    of the fold start and end gets confused. VKRC is identified by the
    &TPVW_VERSION header.



Index: |krl-index|
==============================================================================
                        *krl-highlighting*
krl highlighting:
-----------------
You may have to put >
    syntax on
into your .vimrc to use krl highlighting.

Related krl options
  |g:krlNoHighLink|
  |g:krlShowError|

krl.vim highlighting adds the following |group-name| specialy for Kuka
industrial robots:
    `Sysvars`: Variables starting with $
    `BuildInFunction`: KSS functions
    `Continue`: Contains just the CONTINUE instruction
    `Movement`: Krl movement instructions like "ptp" and movement modifiers like
              "c_ptp"

By default 
    `Sysvars` do look like any other variable, 
    `BuildInFunction` is |hi-link| to |group-name| Function 
    `Continue` is hi-link to group-name Statement and 
    `Movement` is hi-link to group-name Special. 

You can change this by setting |g:krlNoHighLink| to 1, to use your own
linking or highlighting. But the default should be ok for most users and
colorschemes. 

If you like it colorful and the colorscheme torte or motus, you may try the 
colorscheme tortus, which makes use of the krl groups:
  http://www.vim.org/scripts/script.php?script_id=5390
I suggest setting |g:krlNoHighLink| to 1 if using tortus.vim.

You may enable highlighting of some misuses of =, ==, <=, >= and some
more or less common typos by setting |g:krlShowError|.


If you wish to switch off highlighting completely put >
    syntax off
into your |.vimrc| 



Index: |krl-index|
==============================================================================
                        *krl-indent*  
krl indent:
-----------
You may have to put >
    filetype indent on
into your |.vimrc| to use krl indention.

Related krl options:
  |g:krlNoIndent|
  |g:krlNoSpaceIndent|

Note: 
- Tabs are converted to 2 spaces by default.
- A CASE or a DEFAULT get the same level of indention as the corrosponding
   SWITCH and ENDSWITCH.
- A CONTINUE gets the indention of the following line.

Hint: |=| can be combined with movement commands. Example: gg=G will indent
the complete file. To get back where you stopped editing you can use |``|. So
this makes a nice mapping: >
    nnoremap ANYKEY gg=G``zz

See also i_CTRL-F 

You may switch off krl indention completely by setting |g:krlNoIndent| 
to 1.

If you really want a different indention than 2 spaces set |g:krlNoSpaceIndent| 
to 1. Keep in mind that space is rare and tabs look really awful on the teach
pendant.



Index: |krl-index|
==============================================================================
                        *krl-auto-form*  
krl auto form:
--------------
You may have to put >
    filetype plugin on
into your .vimrc to use krl auto form.

Related krl options:
  |g:krlAutoFormKeyMap|
  |g:krlPathToBodyFiles|
  |g:krlAutoFormUpperCase|
  |g:krlNoVerbose|

Set |g:krlAutoFormKeyMap| to quickly create a new DEF, DEFFCT or DEFDAT after
your liking. 

You may type <leader>n anywhere in a *.src, *.sub or *.dat file. You will get
prompted on some details for the new body. The last prompt is the name. The
name prompt is mandatory, all others may be typed quickly after <leader>n. Hit
<esc> or enter an empty string at any prompt to abort.

Example: <leader>ngfb will insert a body for a new global function of type
bool.
Mnemonic: New Global Function of type Bool

If the type does not match the current file type (*.src, *.sub or *.dat), a
a new file with the given name is created. For example if you want a new
DEFDAT in a *.src or vice versa.

You may decide what content will be inserted by setting
|g:krlPathToBodyFiles|, when you use one of those mappings. 

You may put one or more of the following files into this folder: >
  def.src
  deffct.src
  defdat.dat

Those files should contain your custom body for a DEF, DEFFCT and/or DEFDAT.

Example def.src:  >
    <global>def <name>()
      ;
      <|>
      ;
    end ; <name>()

Example deffct.src:  >
    ; ===========================================================
    ; NAME:         <name>()
    ; USAGE:        <|>
    ; DESCRIPTION:  
    ; PARAMETERS:   
    ; RESULT:       <datatype> value ...
    ; NOTES:        
    ; ===========================================================
    <global>deffct <datatype> <name>()
      decl <datatype> <returnvar>
      
      
      return <returnvar>
    endfct

Example defdat.dat:  >
    &ACCESS RVO
    &REL 1
    &COMMENT <name>
    defdat <name><global>
    decl basis_sugg_t LAST_BASIS={POINT1[] "P10                     ",POINT2[] "P20                     ",CP_PARAMS[] "CPDAT10                 ",PTP_PARAMS[] "PDAT10                  ",CONT[] "                        ",CP_VEL[] "2                       ",PTP_VEL[] " 100                    ",SYNC_PARAMS[] "SYNCDAT                 ",SPL_NAME[] "S10                     "}
    
    <|>
    enddat

Note the <Markers> in the example body files. Markers have to be put in
<>. Any marker but | may be present multiple times or omitted.
Markers:  global    substituted by "global " (or " public" if defdat) or ""
          name      substituted by entered name
          type      substituted by "def", "deffct" or "defdat"
          datatype  substituted by the chosen data type
          returnvar substituted by a varname in the form of [prefix]Result
          |         put cursor here when finished

Note that comments or anything below the END line is not supported and may
have unexpected results!

The User group |autocmd-event| `KrlAutoFormPost` will be triggered after the
insertion is finished and may be used for further customization: >
    augroup KrlAutoForm
    au!
    au User KrlAutoFormPost call MyAutoFormPostFunc()
    augroup END



Index: |krl-index|
==============================================================================
                        *krl-word*    *krl-keyword-chars*  
Keyword chars:
--------------
You may have to put >
    filetype plugin on
into your .vimrc

Related krl options:
  |g:krlNoKeyWord|

krl.vim set 'iskeyword' so that KSS variables starting with $, header starting
with & and enum values starting with #, are considered a |word|, for commands
like |w|. You may instruct krl.vim not to change iskeyword if you set
|g:krlNoKeyWord|.



Index: |krl-index|
==============================================================================
                        *krl-jump-quickly*  
Move around quickly:
--------------------
You may have to put >
    filetype plugin on
into your .vimrc

Related krl options:
  |g:krlMoveAroundKeyMap|
  |g:krlGoDefinitionKeyMap|
  |g:krlListUsageKeyMap|
  |g:krlListDefKeyMap|
  |g:krlRhsQuickfix|
  |g:krlLhsQuickfix|
  |g:krlNoVerbose|
  |g:krlNoPath|


File local features:

Set |g:krlMoveAroundKeyMap| to jump quickly between file local def's (or
deffct's) and comments with modified "|]]|", "|][|", "|[[|", "|[]|", "|[;|"
and "|];|" commands. Those take a [count], but things like "d2][" do not work.
Use |Visual|-mode in this case: "|V2][d|". 

Set |g:krlListDefKeyMap| to map <leader>f to populate the quickfix window
with all DEF and/or DEFFCT declarations of the current file.

See also |krl-matchit-support|.


Backup wide features:

ftplugin/krl.vim does set 'path', 'suffixes' and 'suffixesadd' to find files
within a regular KUKA backup folder structure. You may instruct krl.vim not to
change 'path' if you set |g:krlNoPath|. 'suffixes' and 'suffixesadd' get their
values unconditional. This is not only usefull for commands like |:find|,
|gf|, |^Wf| and the like but also necessary for some of the following features.

For the best experience keep your files below the `KRC/` folder.
See |g:krlNoPath| for details on how krl.vim does generate 'path'.

Note to unix/linux users: Keep your files on a filesystem which ingores case
(e.g. FAT) or most of the following features may not work correctly.

Set |g:krlGoDefinitionKeyMap| to use a modified |gd| with the cursor on a
variable or proc/func-call in command mode. A succesful search for a file
local declaration jumps there right away. Get back where you were with |''|. A
succesful search for a more global declaration opens the |quickfix| window.
This also shows Marker definitions in VKRC files, as well as UPs and MAKROs.
Use |gd| on Markers, UPs and MAKROs in the fold lines: ;FOLD 4: SPSMAKRO23 = M15

Set |g:krlListUsageKeyMap| to see quickly where a variable or function or even
an instruction or data type is used. <leader>u shows all appearances of the word
under the cursor, independet of the scope.

|g:krlRhsQuickfix| and |g:krlLhsQuickfix| influence where the
|quickfix-window| will be opened by krl.vim.

In the quickfix window hit <CR> to jump to the line or |gf| to jump to
the file. Get back to where you came from with |''| (file local) or |CTRL-6|
(file comprehensive). See |quickfix-window| for more help with the quickfix
window. 

Some of those commands causes verbose messages. Switch those off with
|g:krlNoVerbose|.


Index: |krl-index|
==============================================================================
                        *krl-matchit-support*  
Match it support:
-----------------
You may have to install the matchit plugin to use this. See |matchit-install|
for help on this. See also http://www.vim.org/scripts/script.php?script_id=39

If |matchit| is loaded you can use |%| to not only jump between (), [] and {}
but also between >
    DEF -> RESUME -> RETURN -> END,
    DEFFCT -> RESUME -> RETURN -> ENDFCT,
    DEFDAT -> ENDDAT,
    IF -> ELSE -> ENDIF, 
    FOR -> EXIT -> ENDFOR, 
    REPEAT -> EXIT -> UNTIL, 
    WHILE -> EXIT -> ENDWHILE,
    LOOP -> EXIT -> ENDLOOP,
    SWITCH -> CASE -> DEFAULT -> ENDSWITCH and
    FOLD -> ENDFOLD

If matchit is installed already, see |matchit| for more information. If 
matchit is not insalled yet have a look into $VIMRUNTIME/macros/matchit.txt.



Index: |krl-index|
==============================================================================
                        *krl-formatting-comments*  
Formatting comments:
--------------------
You may have to put >
    filetype plugin on
into your .vimrc

Related krl options:
  |g:krlFormatComments|
  |g:krlAutoComment|

Set |g:krlFormatComments| to format comments automatically when entered, with
|gq|.

Set |g:krlAutoComment| to continue a comment automatically after hitting 
i_<CR> , |o| or |O| on a comment line.



Index: |krl-index|
==============================================================================
                        *krl-known-bugs*  
Are these really bugs? If your programs and/or frame variables do get proper
names, everything works fine. See below.


Index: |krl-index|
                        *krl-indent-bugs*
Known bugs in |krl-indent|:
-------------------------
1. If a subroutine is named so that it starts with a keyword that will
    decrease the level of indention, then the call is indeted accordingly.
    You can fix this quickly by hitting i_CTRL-F while still in |insert| mode 
    after you finished the complete call, or use i_CTRL-P or i_CTRL-N before 
    the keyword is complete which causes the indention.

    Keywords that decrease the level of indention are: 
    end*, else, case, default, until and continue.
    "continue" only decreases if the next line is one of the other mentioned 
    keywords.

    Example: If a subroutine is called CaseHandling1() you must either type:
    CaseHandling1()^F
    or:
    Cas^P()
    The latter only works if the name already exist anywhere in the
    files you have in buffer.

    Once the call CaseHandling1() is fully present and you are back in
    |Normal| mode you can use |=| to fix the indention.

2. A continue belongs to the following line, so I want it
    to have the same indention as the following line:

    Example: 
    repeat
      stuff()
    continue
    until $in[1]

    Now, if the following "until" does not yet exist, "continue" will be
    indented like the previous line. |=||k| in normal mode after typing "until"
    will fix this.


Index: |krl-index|
                        *krl-highlight-bugs*
Known bugs in |krl-highlighting|:
-------------------------------
1. If a frame is called "in" or "out" (like DECL FRAME In = {X ...) and used
    in an operation with ":" (OutFrame = base_data[1]:In) it is
    highlighted like the ":IN" from "DEF FOO(nInPara:IN)".


Index: |krl-index|
                        *krl-go-definition-bugs*
Known bugs in |g:krlGoDefinitionKeyMap|:
--------------------------------------
1. You can use the modified gd also on user defined STRUC names. If the STRUC
    definition does not exist, you may get a false positive on a variable
    definition which uses this STRUC data type.


Index: |krl-index|

vim:tw=78:ts=4:et:sw=4:ft=help:norl:
